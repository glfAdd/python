##### 事务特性

```
所有操作要么都成功, 要么什么都不做

事务具有四个特征：ACID
原子性（ Atomicity ）: 所有操作要么都成功, 要么什么都不做
一致性（ Consistency ）: 
隔离性（ Isolation ）: 一个事务执行不能干扰其它事务
持续性（ Durability）: 事务一旦提交, 对数据库中的数据的改变就应该是永久性的
```

##### 事务隔离级别

```
1. Read Uncommitted(读取未提交的内容)
所有事物都可以看到其他未提交事务的执行结果，本隔离级别很少用于实际应用，因为他的性能页不比其他级别好多少，读取未提交的数据也被称之为脏读

2. Read Committed(读取提交内容)
一个事物在提交之前对其他事物是不可见的，这种隔离级别也支持所谓的不可重复读取, 因为同一事务的其他实例在该实例处理其他期间可能会有新的commit，所以同一select可能返回不同结果。

3. Repeatable Read(可复读)
mysql默认的隔离级别, 确保同一事务的多个实例在并发读取数据时看到同样的数据行，会导致幻读

4. Serializerable(可串行化)
这是最高的隔离级别，他通过强制事物排序，使之不可能相互冲突，从而解决了幻读问题，简言之，它是在每个读的数据行上加共享锁，在这个级别，可能导致大量的超时现象和锁竞争。


脏读 Dirty Read: 某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个事务RollBack了操作，则后面的事物所读去的数据就是不正确的。
幻读 Phantom Read: 一个事务的两次查询中数据不一致，例如有一个事务查询了几列数据，而另一个事务却在此时插入了新的数据，就会发现有几列数据是他先前所没有的。
不可重复读 Nonerepeatable Read: 一个事物的两次查询中数据不一致，这可能是两次查询过程中间插入了一个事物更新的原有的数据。


                  脏读      不可重复读       幻读
读取未提交内容       v        v               v
读取已提交内容       x        v               v
可重复读            x        x                v
可串行化            x        x                x
```

##### 

```
InnoDB的事务日志主要分为:
redo log是重做日志，提供前滚操作
undo log是回滚日志，提供回滚操作

1.redo log 通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。
2.undo log 是用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。


redo log: 记录的是新数据的备份, 在事务提交前, 只将redo log持久化, 不将数据持久化
当系统崩溃时, 虽然数据没有持久化, 但redo log已经持久化, 根据redo log的内容将数据恢复到最新状态



undo log: 提供事务的回滚和多个行版本控制（MVCC-非锁定读）。undo log是逻辑日志，如执行一条delete操作时，undo log将它的反向操作记录下来，undo log也会产生redo日志。当事务失败需要回滚时，就可以从undo log中的逻辑记录进行回滚到修改前的样子。


```



```
"""
https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html#auto_id_0


每一个操作在真正写入数据数据库之前,先写入到日志文件中
如要删除一行数据会先在日志文件中将此行标记为删除,但是数据库中的数据文件并没有发生变化.
只有在(包含多个sql语句)整个事务提交后,再把整个事务中的sql语句批量同步到磁盘上的数据库文件.



事务的隔离性是通过锁实现，
事务的原子性、一致性和持久性则是通过事务日志实现


innodb事务日志包括redo log和undo log
redo log: 重做日志，提供前滚操作
undo log: 回滚日志，提供回滚操作



"""

""" redo log
事务开启时, 事务中的操作, 都会先写入存储引擎的日志缓冲中, 在事务提交之前, 这些缓冲的日志都需要提前刷新到磁盘上持久化, 这就是"日志先行"(Write-Ahead Logging)
当事务提交之后, 在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘. 
此时如果数据库崩溃或者宕机, 那么当系统重启进行恢复时, 就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。


redo log包括两部分
    - 内存中的日志缓冲(redo log buffer)，该部分日志是易失性的
    - 磁盘上的重做日志文件(redo log file)，该部分日志是持久的

innodb通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。

为了确保每次日志都能写入到事务日志文件中，在每次将log buffer中的日志写入日志文件的过程中都会调用一次操作系统的fsync操作(即fsync()系统调用)。
因为MariaDB/MySQL是工作在用户空间的，MariaDB/MySQL的log buffer处于用户空间的内存中。要写入到磁盘上的log file中(redo:ib_logfileN文件,undo:share tablespace或.ibd文件)，中间还要经过操作系统内核空间的os buffer，调用fsync()的作用就是将OS buffer中的日志刷到磁盘上的log file中。


undo log
记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作




```

