##### 几种树结构

```
树:最上一层是根节点.最底下一层是叶子节点.(一般左边节点小于右边节点)

二叉树:每个节点最多只能有两个分支,一般只用于教材.二叉树的深度不可控,造成遍历数据时IO次数不可控.数据量大了,树的深度会太大.

二叉树的变种:BTREE(又写成B-tree),B+tree和B*tree.

B-tree即balance-tree:平衡树:假设1个节点的子节点是5个,平衡树是必须上层节点都满了,才可加到下层.这样树的深度就得到了控制.B-tree除了在叶子节点保存数据,在非叶子节点也保存数据.

B+tree:所有数据都存储在叶子节点,非叶子节点不存储数据.且叶子节点间构成了双向链表。Mysql用的方法是B+tree.

b+tree的插入必须要保证插入后，叶子节点的数据依然有序。而且不管怎么变化，根节点到叶子节点的深度始终是相同的。

B*tree:也只在叶子节点存储数据并构成双向指针,但在非叶子节点有双向指针。
```

##### 聚簇索引表

```
innodb将表结构数据存储在一个B+TREE中,B+TREE叫聚簇索引(cluster-index).
以聚簇索引构建的表叫聚簇索引表,又称索引组织表, 表结构本身就是索引。
聚集索引页的叶子节点汇总存放着完整的记录，副主索引页中存放着指向叶子的指针。
聚集索引是通过将表的主键作为键值来构造B+树的,因为innoDB存储引擎是通过主键来构造的,所以这需要每一张表都有主键,如果没有显式的指定主键,那么数据库是自动创建主键,聚集索引不仅仅包含索引的键值,还包含了记录所在其他列的值,聚集索引中的记录是根据键值顺序排列的,但是不是物理排序,而是顺序排序。
说明：

1.根据主键寻址速度很快
2.主键值递增的insert插入效率较好
3.主键值随机insert插入操作效率差

建议：innodb表必须指定主键，最好使用自增数字；
```

##### 聚簇索引构建规则

```
1.有主键, 用主键来构建聚簇索引.
2.没有主键, 如果有唯一性非空索引,就用该索引构建.
3.都没有, 则开辟一个6字节的隐藏列,用隐藏列构建主键索引.
```

##### 索引分类

```
逻辑上: 单列索引, 多列索引, 唯一索引, 非唯一索引
物理上: 聚簇索引, 非聚簇索引
```

##### 哪些情况下建议创建索引

```
经常搜索的列
经常用在表连接的列
经常需要排序的列
经常使用在WHERE子句中的列
```

##### 辅助索引

```
1. 辅助索引又称二级索引或非聚簇索引.
2. 辅助索引也是B+tree,叶子节点存放的是索引列和主键值,不存放其他列信息.若无主键,则存放的是索引列和该表聚簇索引的虚拟主键值.辅助索引是根据索引列的值排序.
3. 在聚簇索引和辅助索引都存在的时候，优化器倾向于使用聚簇索引，因为聚簇索引可以通过叶子节点找到数据。
4. 通过辅助索引查询记录仅仅只能得到主键值，要查询完整的记录，还需要通过一次聚簇索引查询。（回表）
5. 聚簇索引通常比辅助索引的高度要高（辅助索引不保存所有记录，更小，高度更低）。
```

##### 覆盖索引

```
一个查询语句的执行只需要从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。
特高频SQL，强烈推荐使用覆盖索引，可以非常大的提高查询效率。
```

##### 回表

```
指当通过辅助索引查询得到的记录信息不足,需要回表再通过聚簇索引查询信息
```

##### 复合索引

```
建立在多个列上的索引
遵从最左前缀原则
```

##### 索引下推

```
索引下推: ICP(Index Condition Pushdown)
它能减少使用二级索引过滤where条件时的回表次数

不使用ICP, 通过二级索引进行查询，存储引擎通过索引检索数据，然后返回给MySQL服务器，MySQL服务器再判断是否符合条件。

使用ICP，当存在索引的列做为判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。
```

