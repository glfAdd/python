## 并发

##### 并发场景

```
读-读：不存在任何问题，也不需要并发控制 
读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读 
写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失
```

##### 并发问题

- 脏读

  ```
  Dirty Read: 事务 1 更新了一份数据, 此时事务 2 读取了这份数据, 事务 1 rollback 了操作, 导致事务 2 读取的数据是不正确的.  
  ```

- 幻读

  ```
  Phantom Read: 在一个事务内，同一 SELECT 多次读取范围内数据, 得到结果集不同. 侧重数据增加或减少.
  
  例如: 事务 1 查询了所有的数据, 此时事务 2 插入了新的数据, 事务 1 再次查询所有数据, 发现数据多了.
  ```

  | 事务 1                | 事务 2                                    |
  | --------------------- | ----------------------------------------- |
  | begin;                |                                           |
  | select * from person; |                                           |
  |                       | begin;                                    |
  |                       | insert into person (name) values ('Tom'); |
  |                       | commit;                                   |
  | select * from person; |                                           |
  | commit;               |                                           |

- 不可重复读

  ```
  Nonerepeatable Read: 在一个事务内, 同一 select 多次读取同一条数据, 得到结果不同. 侧重数据被修改.
  
  例如: 事务 1 查询一条数据, 得到结果为 100, 此时事务 2 修改了这条数据为 200, 此时事务 1 再次读取时变为了200
  ```

## mvcc

##### 并发问题的解决办法

```
1. 数据库通常使用锁来实现隔离性, 最原生的锁, 锁住一个资源后会禁止其他任何线程访问同一个资源

2. 但是很多应用读多写少, 所以就使用了一种读写锁的方法. 使读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥。这样就很大提升了系统的并发能力。

3. 并发读还是不够，又提出了读写之间也不冲突的方法. 读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据.
```

##### 是什么

```
1. 多版本并发控制 Multiversion Concurrency Control, 简称 MVCC. 提高数据库并发性能
2. 解决读写冲突的无锁并发控制, 读操作只读该事务开始前的数据库的快照
3. 降低了死锁的概率. InnoDB 的 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行
4. 解决一致性读的问题, 当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果
5. MySQL, Oracle, PostgreSQL等其他数据库系统也都实现了MVCC，但各自的实现机制不同

对正在事务内处理的数据做多版本的管理，用来避免由于写操作的堵塞，而引发读操作失败的并发问题。


MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现


是通过保存数据在某个时间点的快照来实现并发控制的. 不管事务执行多长时间，事务内部看到的数据是不受其它事务影响的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。



乐观（optimistic）并发控制和悲观（pessimistic）并发控制




MVCC 在一定程度上实现了读写并发，它只在 可重复读（REPEATABLE READ） 和 提交读（READ COMMITTED） 两个隔离级别下工作。其他两个隔离级别都和 MVCC 不兼容，因为 未提交读（READ UNCOMMITTED），总是读取最新的数据行，而不是符合当前事务版本的数据行。而 可串行化（SERIALIZABLE） 则会对所有读取的行都加锁。

行锁，并发，事务回滚等多种特性都和MVCC相关。

```

```
MVCC + 悲观锁: MVCC解决读写冲突，悲观锁解决写写冲突
MVCC + 乐观锁: MVCC解决读写冲突，乐观锁解决写写冲突
```

##### 隐藏字段

每行记录除了我们自定义的字段外，数据库隐式定义一些字段

|             | 大小 byte |                                                              |
| ----------- | --------- | ------------------------------------------------------------ |
| DB_ROW_ID   | 6         | 隐含的自增ID（隐藏主键）, 如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引 |
| DB_TRX_ID   | 6         | 最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID |
| DB_ROLL_PTR | 7         | 回滚指针，指向这条记录的上一个版本（存储于rollback segment里） |
| DELETED_BIT | 1         | 记录被更新或删除并不代表真的删除，而是删除flag变了           |

##### undo log

InnoDB 将行记录快照保存在了 Undo Log 里



<img src=".\image\undolog.png" alt="undolog" style="zoom:80%;" />

```
回滚指针将数据行的所有快照记录都通过链表的结构串联了起来，每个快照的记录都保存了当时的 db_trx_id, 可以通过遍历回滚指针的方式进行查找
```





##### 可重复读隔离级别 InnoDB 的 MVCC 是如何工作

```
查询（SELECT）
InnoDB 会根据以下两个条件检查每行记录：

1. InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
2. 行的删除版本要么未定义，要么大于当前事务版本号 ??????
只有符合上述两个条件的记录，才能返回作为查询结果。


插入（INSERT）
InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

删除（DELETE）
InnoDB为删除的每一行保存当前系统版本号作为行删除标识。
删除在内部被视为更新，行中的一个特殊位会被设置为已删除。

更新（UPDATE）
InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。
```



```
mvcc 快照读和当前读



```

##### mvcc 问题

```
数据库状态的快照适用于事务中的SELECT语句, 而不一定适用于所有DML语句
如果插入或修改某些行, 然后提交该事务, 则从另一个并发REPEATABLE READ事务发出的DELETE或UPDATE语句就可能会影响那些刚刚提交的行, 即使该事务无法查询它们。 如果事务更新或删除由不同事务提交的行, 则这些更改对当前事务变得可见


表中 id 为主键
事务 1 开始
事务 2 开始
事务 1 插入 id 为 100 的数据, 并 commit
事务 2 插入 id 为 100 的数据, 提示失败
```





## 事务

##### 事务特性

```
所有操作要么都成功, 要么什么都不做

事务具有四个特征：ACID
原子性（ Atomicity ）: 所有操作要么都成功, 要么什么都不做
一致性（ Consistency ）: 
隔离性（ Isolation ）: 一个事务执行不能干扰其它事务
持续性（ Durability）: 事务一旦提交, 对数据库中的数据的改变就应该是永久性的
```

##### 查询事务隔离级别

```sql
show variables like 'transaction_isolation';
```

##### 事务隔离级别

```
1. Read Uncommitted(读未提交)
可以读取未提交的内容

2. Read Committed(读提交)
只能读取已经提交的内容, 采用快照读

3. Repeatable Read(可重复读)
mysql默认的隔离级别, 确保同一事务的多个实例在并发读取数据时看到同样的数据行，会导致幻读

4. Serializerable(串行化)
最高隔离级别, 顺序执行事务.
```

|          | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 读未提交 | Y    | Y          | Y    |
| 读提交   | N    | Y          | Y    |
| 可重复读 | N    | N          | Y    |
| 串行化   | N    | N          | N    |

##### 快照读

- 快照读(SnapShot Read): 事务查询到的数据都是事务开始前已存在或事务自身写的数据.

- 快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读

- 快照读的实现是基于多版本并发控制

  ```sql
  -- 不加锁的简单的 SELECT 都属于快照读
  SELECT * FROM t WHERE id=1;
  ```

##### 当前读

- 当前读: 查询最新版本的记录，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁

  ```sql
  -- 加锁的 SELECT 就属于当前读
  SELECT * FROM t WHERE id=1 LOCK IN SHARE MODE;
  SELECT * FROM t WHERE id=1 FOR UPDATE;
  ```

```
InnoDB的事务日志主要分为:
redo log是重做日志，提供前滚操作
undo log是回滚日志，提供回滚操作

1.redo log 通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。
2.undo log 是用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。


redo log: 记录的是新数据的备份, 在事务提交前, 只将redo log持久化, 不将数据持久化
当系统崩溃时, 虽然数据没有持久化, 但redo log已经持久化, 根据redo log的内容将数据恢复到最新状态



undo log: 提供事务的回滚和多个行版本控制（MVCC-非锁定读）。undo log是逻辑日志，如执行一条delete操作时，undo log将它的反向操作记录下来，undo log也会产生redo日志。当事务失败需要回滚时，就可以从undo log中的逻辑记录进行回滚到修改前的样子。


```



```
"""
https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html#auto_id_0


每一个操作在真正写入数据数据库之前,先写入到日志文件中
如要删除一行数据会先在日志文件中将此行标记为删除,但是数据库中的数据文件并没有发生变化.
只有在(包含多个sql语句)整个事务提交后,再把整个事务中的sql语句批量同步到磁盘上的数据库文件.



事务的隔离性是通过锁实现，
事务的原子性、一致性和持久性则是通过事务日志实现


innodb事务日志包括redo log和undo log
redo log: 重做日志，提供前滚操作
undo log: 回滚日志，提供回滚操作



"""

""" redo log
事务开启时, 事务中的操作, 都会先写入存储引擎的日志缓冲中, 在事务提交之前, 这些缓冲的日志都需要提前刷新到磁盘上持久化, 这就是"日志先行"(Write-Ahead Logging)
当事务提交之后, 在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘. 
此时如果数据库崩溃或者宕机, 那么当系统重启进行恢复时, 就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。


redo log包括两部分
    - 内存中的日志缓冲(redo log buffer)，该部分日志是易失性的
    - 磁盘上的重做日志文件(redo log file)，该部分日志是持久的

innodb通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。

为了确保每次日志都能写入到事务日志文件中，在每次将log buffer中的日志写入日志文件的过程中都会调用一次操作系统的fsync操作(即fsync()系统调用)。
因为MariaDB/MySQL是工作在用户空间的，MariaDB/MySQL的log buffer处于用户空间的内存中。要写入到磁盘上的log file中(redo:ib_logfileN文件,undo:share tablespace或.ibd文件)，中间还要经过操作系统内核空间的os buffer，调用fsync()的作用就是将OS buffer中的日志刷到磁盘上的log file中。


undo log
记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作




```







https://segmentfault.com/a/1190000037557620

https://blog.csdn.net/Waves___/article/details/105295060



##### select 语句分类

```
首先我们的 SELECT 查询分为快照读和实时读，快照读通过 MVCC（并发多版本控制）来解决幻读问题，实时读通过行锁来解决幻读问题。
```





## innodb

##### select

##### insert

##### delete

##### update

