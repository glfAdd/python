##### Redis支持的数据类型

```
String 字符串
字符串, 整数, 浮点
string类型是二进制, 可以包含任何数据, 比如jpg图片或者序列化的对象, 一个键最大能存储512MB

Hash（哈希）
键值对集合, 是一个string类型的field和value的映射表，hash特别适合用于存储对象。
hmset name  key1 value1 key2 value2

List（列表）
字符串列表, 可以添加元素到列表的头部（左边）或者尾部（右边）

Set（集合）
string类型的无序集合, 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)

zset(有序集合)
string类型元素的集合, 且不允许重复的成员。
格式: zadd  name score value
不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
zset的成员是唯一的,但分数(score)却可以重复。
```

##### 快照持久化 RDB

```

持久化: 把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。
除了进行持久化之外，用户还必须对持久化所得的文件进行备份(最好是备份到多个不同的地方),这样才能尽量避免数据丢失事故发生。如果条件允许的话，最好能将快照文件和最新重写的AOF文件备份到不同的服务器上面。

创建子进程进行快照
系统发生崩溃丢失快照后更改的所有数据. 适用于丢失一部份数据也不会造成问题的应用程序

例子
  - 如果内存有10GB数据, 上一个快照2:31开始创建并成功, 3:12开始创建快照, 创建之前有51个键进行更新
  - 如果创建成功之前系统崩溃, 则丢失2:31之后的所有数据
  - 如果创建成功以后系统崩溃, 则丢失51的更新

配置文件
save 60 1000
stop-writes-on-bgsave-error no
rdbcompression yes
dbfilename dump.rdb
```

##### AOF持久化

```

将被执行的写命令写到AOF文件末尾, 以此来记录发生的变化. 

缺陷
  - 不断地将被执行的写命令记录到AOF文件，Redis不断运行，AOF文件的体积也会不断增长，在极端情况下，体积不断增大的AOF文件甚至可能会用完硬盘的所有可用空间。
  - 重新执行AOF文件记录的所有写命令来还原数据集，如果AOF文件的体积非常大, 还原操作执行的时间就可能会非常长。

文件同步在向硬盘写入文件时至少会发生3件事
1. 当调用file.write()方法对文件进行写入时，写入的内容首先会被存储到缓冲区
2. 然后操作系统会在将来的某个时候将缓冲区存储的内容写入硬盘，数据只有在被写入硬盘之后，才算是真正地保存到了硬盘里面。
   用户可以通过调用file.flush()方法来请求操作系统尽快地将缓冲区存储的数据写入硬盘里，但具体何时执行写入操作仍然由操作系统决定。
3. 用户可以命令操作系统将文件同步(sync) 到硬盘，同步操作会一直阻塞直到指定的文件被写入硬盘为止。当同步操作执行完毕之后，即使系统出现故障也不会对被同步的文件造成任何影响。

同步频率 appendfsync
  - always      每个写命令都同步写入硬盘, 严重降低redis速度, 用户几乎可以不损失任何数据
                每次只写入一条命令, 其他选项一次写入多条命令
                这种同步频率下, 机械硬盘每秒大约处理200个命令, 固态硬盘几万个命令
  - everysec    每秒执行一次同步
                兼顾数据安全和写入性能
                每秒同步一次AOF文件时的性能和不使用任何持久化特性时的性能相差无几
                系统崩溃，用户也最多只会丢失一秒之内产生的数据。当硬盘忙于执行写人操作的时候，Redis还会优雅地放慢自己的速度以便适应硬盘的最大写人速度。
  - no          由操作系统来决定应该在何时对AOF文件进行同步
                一般情况下不会对Redis的性能带来影响，但系统崩溃将导致使用这种选项的Redis服务器丢失不定数量的数据
                如果用户的硬盘处理写入操作的速度不够快的话,那么当缓冲区被等待写入硬盘的数据填满时，Redis 的写人操作将被阻塞，并导致Redis处理命令请求的速度变慢, 因为这个原因不推荐使用



BGREWRITEAOF
为了解决AOF文件体积不断增大的问题，用户可以向Redis发送BGREWRITEAOF命令, 这个命令会通过移除AOF文件中的冗余命令来重写AOF文件, 使AOF文件的体积变得尽可能地小。
  - 1. Redis创建一个子进程重写AOF文件, 会导致的性能问题和内存占用问题
  - 2. AOF文件的体积可能会比快照文件的体积大好几倍, 在进行AOF重写并删除旧AOF文件的时候，删除一个体积达到数十GB大的旧AOF文件可能会导致操作系统挂起数秒

配置文件
appendonly no
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb  
# 当AOF文件体积大于64MB, 且AOF文件的体积比上一次重写之后的体积大了至少100%时候, Redis将执行BGREWRITEAOF命令
```

