""" ============================ Redis支持的数据类型
String字符串
字符串, 整数, 浮点
# string类型是二进制, 可以包含任何数据, 比如jpg图片或者序列化的对象, 一个键最大能存储512MB

Hash（哈希）
键值对集合, 是一个string类型的field和value的映射表，hash特别适合用于存储对象。
hmset name  key1 value1 key2 value2

List（列表）
字符串列表, 可以添加元素到列表的头部（左边）或者尾部（右边）

Set（集合）
string类型的无序集合, 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)

zset(有序集合)
string类型元素的集合, 且不允许重复的成员。
格式: zadd  name score value
不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
zset的成员是唯一的,但分数(score)却可以重复。
"""

""" ============================ 快照持久化 RDB
持久化: 把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。
除了进行持久化之外，用户还必须对持久化所得的文件进行备份(最好是备份到多个不同的地方),这样才能尽量避免数据丢失事故发生。如果条件允许的话，最好能将快照文件和最新重写的AOF文件备份到不同的服务器上面。

创建子进程进行快照
系统发生崩溃丢失快照后更改的所有数据. 适用于丢失一部份数据也不会造成问题的应用程序

例子
  - 如果内存有10GB数据, 上一个快照2:31开始创建并成功, 3:12开始创建快照, 创建之前有51个键进行更新
  - 如果创建成功之前系统崩溃, 则丢失2:31之后的所有数据
  - 如果创建成功以后系统崩溃, 则丢失51的更新

配置文件
save 60 1000
stop-writes-on-bgsave-error no
rdbcompression yes
dbfilename dump.rdb
"""

""" ============================ AOF持久化
将被执行的写命令写到AOF文件末尾, 以此来记录发生的变化. 

缺陷
  - 不断地将被执行的写命令记录到AOF文件，Redis不断运行，AOF文件的体积也会不断增长，在极端情况下，体积不断增大的AOF文件甚至可能会用完硬盘的所有可用空间。
  - 重新执行AOF文件记录的所有写命令来还原数据集，如果AOF文件的体积非常大, 还原操作执行的时间就可能会非常长。

文件同步在向硬盘写入文件时至少会发生3件事
1. 当调用file.write()方法对文件进行写入时，写入的内容首先会被存储到缓冲区
2. 然后操作系统会在将来的某个时候将缓冲区存储的内容写入硬盘，数据只有在被写入硬盘之后，才算是真正地保存到了硬盘里面。
   用户可以通过调用file.flush()方法来请求操作系统尽快地将缓冲区存储的数据写入硬盘里，但具体何时执行写入操作仍然由操作系统决定。
3. 用户可以命令操作系统将文件同步(sync) 到硬盘，同步操作会一直阻塞直到指定的文件被写入硬盘为止。当同步操作执行完毕之后，即使系统出现故障也不会对被同步的文件造成任何影响。

同步频率 appendfsync
  - always      每个写命令都同步写入硬盘, 严重降低redis速度, 用户几乎可以不损失任何数据
                每次只写入一条命令, 其他选项一次写入多条命令
                这种同步频率下, 机械硬盘每秒大约处理200个命令, 固态硬盘几万个命令
  - everysec    每秒执行一次同步
                兼顾数据安全和写入性能
                每秒同步一次AOF文件时的性能和不使用任何持久化特性时的性能相差无几
                系统崩溃，用户也最多只会丢失一秒之内产生的数据。当硬盘忙于执行写人操作的时候，Redis还会优雅地放慢自己的速度以便适应硬盘的最大写人速度。
  - no          由操作系统来决定应该在何时对AOF文件进行同步
                一般情况下不会对Redis的性能带来影响，但系统崩溃将导致使用这种选项的Redis服务器丢失不定数量的数据
                如果用户的硬盘处理写入操作的速度不够快的话,那么当缓冲区被等待写入硬盘的数据填满时，Redis 的写人操作将被阻塞，并导致Redis处理命令请求的速度变慢, 因为这个原因不推荐使用



BGREWRITEAOF
为了解决AOF文件体积不断增大的问题，用户可以向Redis发送BGREWRITEAOF命令, 这个命令会通过移除AOF文件中的冗余命令来重写AOF文件, 使AOF文件的体积变得尽可能地小。
  - 1. Redis创建一个子进程重写AOF文件, 会导致的性能问题和内存占用问题
  - 2. AOF文件的体积可能会比快照文件的体积大好几倍, 在进行AOF重写并删除旧AOF文件的时候，删除一个体积达到数十GB大的旧AOF文件可能会导致操作系统挂起数秒

配置文件
appendonly no
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb  
# 当AOF文件体积大于64MB, 且AOF文件的体积比上一次重写之后的体积大了至少100%时候, Redis将执行BGREWRITEAOF命令
"""

""" ============================ 复制
如果主从服务器之间的网络带宽不足, 或者主服务器没有足够的内存来创建子进程和创建记录写命令的缓冲区，那么Redis 处理命令请求的效率就会受到影响。
最好还是让主服务器只使用50%~ 65%的内存，留下30%~ 45%的内存用于执行BGSAVE命令和创建记录写命令的缓冲区。
从服务器在与主服务器进行初始连接时，数据库中原有的所有数据都将丢失，并被替换成主服务器发来的数据。
同时使用复制和AOF持久化将数据持久化到多台机器上面

从服务器连接主服务器步骤
  步骤     主服务器操作                                                                  从服务器操作
  1       (等待命令进入)                                                                连接主服务器, 发送SYNC命令
  2       开始执行bgsave, 并使用缓冲区记录bgsave之后执行的所有命令                          根据配置选项决定是否继续使用现有的数据处理客户端的命令请求, 还是想发送请求的客户端返回错误
  3       bgsave执行完毕向从服务器发送快照文件, 期间继续使用缓冲区记录被执行的写命令           丢弃所有旧数据, 载入主服务器发来的快照文件
  4       快照文件发送完毕, 开始向从服务器发送存储的缓冲区里的写命令                          完成快照文件解释操作, 并开始接收命令请求
  5       缓冲区存储的写命令发送完毕, 从现在开始每执行一个写命令就向从服务器发送相同的命令       执行主服务器发来的所有缓冲区里面的写命令. 从现在开始接收并执行主服务器传来的每个写命令

主从链
  - 从服务器也可以有从服务器
  - 从服务器对从服务器复制和从服务器对主服务器复制唯一区别在于, 如果从服务器X拥有从服务器Y, 那么当从服务器X在执行表步骤4时，它将断开与从服务器Y的连接，导致从服务器Y需要重新连接并重新同步
"""

""" ============================ Redis 有哪些架构模式
单机版: 内存容量有限, 处理能力有限, 无法高可用
主从复制
"""

""" ============================ 短结构
短结构, 分片结构, 打包存储二进制和字节
"""

""" ============================ 命令 字符串
set k v
get k
del k

incr k                  值自增1
decr k                  值自减1
incrby k n              值加n
decrbu k n              值减n
incrbyfloat k n         值加浮点n

append k v              值末尾追加字符串
getrange k start end    获取start和end之间字符
setrange k start v      从start开始替换为v
getbit
setbit
bitcount
bitop

* 对不存在的值进行自增/自减, 会将这个值当0处理
* 对无法解释为整数/浮点的字符串自增/自减返回错误
"""

""" ============================ 命令 列表
lpush k v1 v2           左边添加多个元素
rpush k v1 v2           右边添加多个元素
lpop k
rpop k
lindex k v              获取指定位置上一个元素
lrange k start end      获取指定范围所有元素
ltrim k start end       只保留start和end及之间的元素  

blpop k timeout         从第一个非空列表中弹出最左边元素, 或timeout内等待可弹出的元素出现                   
brpop                                        右
rpoplpush k1 k2         弹出k1最右边, 推入k2最左, 并获取这个元素
brpoplpush k1 k2 timeout弹出k1最右边, 推入k2最左, 并获取这个元素, 如果k1位空则阻塞timeout直到元素出现
"""

""" ============================ 命令 集合
sadd k v1 v2            添加1个/多个元素, 获取不存在新增加的个数        
srem k v1 v2            删除1个/多个元素, 获取删除的个数
scard k                 获取元素个数
smembers k              获取所有元素
sismember k v           是否包含元素v
srandmember k count     随机获取count个元素, 当count为正数时元素不重复, 负数时可以重复
spop k                  随机移除一个元素并获取元素
smove k1 k2 v           如果k1有元素v则移动到k2则
"""

""" ============================ 命令 散列
hset k1 k2 v
hget k1 k2
hdel k1 k2
hgetall k1              获取所有键值对
hmget K k1 k2           获取1个/多个键的值
hmset K k1 v1 k2 v2     添加1个/多个值
hdel K k1 k2            获取成功删除的数量
hlen K                  获取键值对的数量
hexists K k             查看k是否存在
hkeys K k               删除
hvals K                 获取所有值
hgetall K               获取所有键值对
hincrby K k count       值加上count
hincrbyfloat K k count  值加上count 浮zrange点
"""

""" ============================ 命令 有序集合
有序集合
zadd k s1 v1 s2 v2      将分数s1 s2和元素添加到集合
zrem k v1 v2            移除元素, 并获取成功的数量            
zcard k                 获取元素数量
zincrby k count v       v的分数增加count
zcount k s1 s2          获取分数s1和s2之间元素数量
zrank k v               获取元素的排名
zscore k v              获取元素的分值
zrange k start stop [withscores]    返回排名start和stop之间的成员, 如果有withscores则一起返回分数
"""
